<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dummy - Weather's Weird Side</title>
  
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  
  <style>
    :root {
      --red: #dc2626;
      --blue: #3b82f6;
      --green: #10b981;
      --amber: #f59e0b;
      --gray: #f3f4f6;
      --dark: #0f172a;
      --muted: #64748b;
      --card: #ffffff;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: system-ui, -apple-system, sans-serif; 
      background: var(--gray); 
      color: var(--dark);
    }
    
    header {
      background: var(--card);
      border-bottom: 3px solid var(--red);
      padding: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 1000;
    }
    
    .logo {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .daymark {
      width: 30px;
      height: 45px;
      background: repeating-linear-gradient(
        to bottom,
        var(--red) 0px,
        var(--red) 6px,
        white 6px,
        white 12px
      );
      clip-path: polygon(50% 0%, 100% 100%, 0% 100%);
    }
    
    h1 {
      font-size: 1.5rem;
      font-weight: 900;
      color: var(--red);
      letter-spacing: -0.02em;
    }
    
    .location-control {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      background: var(--gray);
      padding: 0.5rem 1rem;
      border-radius: 999px;
    }
    
    .location-control input {
      border: none;
      background: none;
      outline: none;
      width: 200px;
    }
    
    .tabs {
      display: flex;
      background: var(--card);
      padding: 0.5rem;
      gap: 0.5rem;
    }
    
    .tab {
      padding: 0.75rem 1.5rem;
      border: none;
      background: transparent;
      font-weight: 700;
      cursor: pointer;
      border-radius: 0.5rem;
      transition: all 0.2s;
    }
    
    .tab:hover { background: var(--gray); }
    .tab.active { 
      background: var(--red); 
      color: white;
    }
    
    .content {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }
    
    .section { display: none; }
    .section.active { display: block; }
    
    .card {
      background: var(--card);
      border-radius: 1rem;
      padding: 1.5rem;
      margin: 1rem 0;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
    }
    
    .metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin: 1.5rem 0;
    }
    
    .metric {
      text-align: center;
      padding: 1rem;
      background: var(--gray);
      border-radius: 0.75rem;
    }
    
    .metric-value {
      font-size: 2rem;
      font-weight: 900;
      color: var(--red);
    }
    
    .metric-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      color: var(--muted);
      margin-top: 0.25rem;
    }
    
    .map {
      height: 500px;
      border-radius: 1rem;
      overflow: hidden;
      margin: 1rem 0;
    }
    
    .insight {
      background: linear-gradient(90deg, rgba(59,130,246,0.1), transparent);
      border-left: 3px solid var(--blue);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 0.5rem 0.5rem 0;
    }
    
    .data-age {
      position: absolute;
      top: 1rem;
      right: 1rem;
      padding: 0.25rem 0.75rem;
      background: rgba(255,255,255,0.9);
      border-radius: 999px;
      font-size: 0.75rem;
      color: var(--muted);
    }
    
    .twin-card {
      background: var(--gray);
      padding: 1rem;
      border-radius: 0.75rem;
      margin: 0.5rem 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .pressure-indicator {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      font-weight: 700;
      font-size: 0.875rem;
    }
    
    .high-pressure { background: #fee2e2; color: #dc2626; }
    .low-pressure { background: #dbeafe; color: #3b82f6; }
    
    @media (max-width: 768px) {
      .location-control input { width: 120px; }
      .metrics { grid-template-columns: repeat(2, 1fr); }
    }
  </style>
</head>
<body>

<header>
  <div class="logo">
    <div class="daymark"></div>
    <h1>DUMMY</h1>
  </div>
  <div class="location-control">
    <span>üìç</span>
    <input type="text" id="locationInput" placeholder="Click map or enter city">
    <button onclick="setLocation()">Set</button>
  </div>
</header>

<nav class="tabs">
  <button class="tab active" onclick="switchTab('local')">Your Weather</button>
  <button class="tab" onclick="switchTab('twins')">Weather Twins</button>
  <button class="tab" onclick="switchTab('pressure')">Pressure Chase</button>
  <button class="tab" onclick="switchTab('roulette')">Weather Roulette</button>
</nav>

<div class="content">
  <!-- Your Weather -->
  <section id="local" class="section active">
    <div class="card">
      <div class="data-age" id="dataAge">Data: -- min old</div>
      <h2>Your Exact Weather</h2>
      <p style="color: var(--muted); margin-top: 0.5rem;">Click anywhere on map to change location</p>
      
      <div class="metrics">
        <div class="metric">
          <div class="metric-value" id="temp">--¬∞</div>
          <div class="metric-label">Temperature</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="wetbulb">--¬∞</div>
          <div class="metric-label">Wet Bulb</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="dewpoint">--¬∞</div>
          <div class="metric-label">Dew Point</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="vpd">-- kPa</div>
          <div class="metric-label">VPD</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="spread">--¬∞</div>
          <div class="metric-label">T-Td Spread</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="pressure">-- mb</div>
          <div class="metric-label">Pressure</div>
        </div>
      </div>
      
      <div class="insight" id="moistureInsight">
        Analyzing moisture dynamics...
      </div>
      
      <div class="insight" id="condensationRisk">
        Condensation risk assessment...
      </div>
      
      <div id="localMap" class="map"></div>
    </div>
  </section>
  
  <!-- Weather Twins -->
  <section id="twins" class="section">
    <div class="card">
      <h2>Weather Twins</h2>
      <p style="color: var(--muted);">Places experiencing your exact weather profile right now</p>
      
      <div id="twinsList"></div>
      <div id="twinsMap" class="map"></div>
    </div>
  </section>
  
  <!-- Pressure Chase -->
  <section id="pressure" class="section">
    <div class="card">
      <h2>Pressure Chase</h2>
      <p style="color: var(--muted);">Live atmospheric pressure systems - watch weather being born</p>
      
      <div id="pressureMap" class="map"></div>
      
      <div id="pressureSystems"></div>
    </div>
  </section>
  
  <!-- Weather Roulette -->
  <section id="roulette" class="section">
    <div class="card">
      <h2>Weather Roulette</h2>
      <p style="color: var(--muted);">Click anywhere on the map for a 3-way comparison</p>
      
      <div id="rouletteMap" class="map"></div>
      
      <div id="rouletteResults"></div>
    </div>
  </section>
</div>

<script>
// State
let userLocation = {lat: 40.7128, lon: -74.0060};
let maps = {};

// Weather Service
class Weather {
  constructor() {
    this.cache = new Map();
    this.CACHE_TIME = 5 * 60 * 1000;
  }
  
  async get(lat, lon) {
    const key = `${lat.toFixed(2)},${lon.toFixed(2)}`;
    const cached = this.cache.get(key);
    if (cached && Date.now() - cached.time < this.CACHE_TIME) {
      return cached.data;
    }
    
    // Try NOAA first
    if (lat > 24 && lat < 50 && lon > -125 && lon < -66) {
      try {
        const point = await fetch(`https://api.weather.gov/points/${lat.toFixed(4)},${lon.toFixed(4)}`);
        const pData = await point.json();
        const obs = await fetch(pData.properties.observationStations);
        const stations = await obs.json();
        
        if (stations.features && stations.features.length > 0) {
          const station = stations.features[0].id;
          const latest = await fetch(`${station}/observations/latest`);
          const data = await latest.json();
          const props = data.properties;
          
          const result = {
            temp: Math.round(props.temperature.value * 9/5 + 32),
            dewpoint: Math.round(props.dewpoint.value * 9/5 + 32),
            humidity: props.relativeHumidity.value,
            pressure: Math.round(props.barometricPressure.value / 100),
            wind: Math.round(props.windSpeed.value * 2.237),
            timestamp: new Date(props.timestamp),
            source: 'NOAA'
          };
          
          this.cache.set(key, {data: result, time: Date.now()});
          return result;
        }
      } catch(e) {
        console.log('NOAA failed, trying Open-Meteo');
      }
    }
    
    // Fallback to Open-Meteo
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,dew_point_2m,surface_pressure,wind_speed_10m&temperature_unit=fahrenheit&wind_speed_unit=mph`;
    const resp = await fetch(url);
    const data = await resp.json();
    
    const result = {
      temp: Math.round(data.current.temperature_2m),
      dewpoint: Math.round(data.current.dew_point_2m),
      humidity: data.current.relative_humidity_2m,
      pressure: Math.round(data.current.surface_pressure),
      wind: Math.round(data.current.wind_speed_10m),
      timestamp: new Date(),
      source: 'Open-Meteo'
    };
    
    this.cache.set(key, {data: result, time: Date.now()});
    return result;
  }
}

const weather = new Weather();

// Calculate wet bulb temperature
function wetBulb(tempF, rh) {
  const tempC = (tempF - 32) * 5/9;
  const wetBulbC = tempC * Math.atan(0.151977 * Math.sqrt(rh + 8.313659)) +
    Math.atan(tempC + rh) - Math.atan(rh - 1.676331) +
    0.00391838 * Math.pow(rh, 1.5) * Math.atan(0.023101 * rh) - 4.686035;
  return Math.round(wetBulbC * 9/5 + 32);
}

// Calculate VPD
function vaporPressureDeficit(tempF, rh) {
  const tempC = (tempF - 32) * 5/9;
  const svp = 0.6108 * Math.exp(17.27 * tempC / (tempC + 237.3));
  const avp = svp * rh / 100;
  return (svp - avp).toFixed(2);
}

// Update local weather
async function updateLocal() {
  const data = await weather.get(userLocation.lat, userLocation.lon);
  
  // Update metrics
  document.getElementById('temp').textContent = `${data.temp}¬∞`;
  document.getElementById('dewpoint').textContent = `${data.dewpoint}¬∞`;
  document.getElementById('wetbulb').textContent = `${wetBulb(data.temp, data.humidity)}¬∞`;
  document.getElementById('vpd').textContent = `${vaporPressureDeficit(data.temp, data.humidity)}`;
  document.getElementById('spread').textContent = `${data.temp - data.dewpoint}¬∞`;
  document.getElementById('pressure').textContent = `${data.pressure}`;
  
  // Data age
  const ageMin = Math.round((Date.now() - data.timestamp) / 60000);
  document.getElementById('dataAge').textContent = `Data: ${ageMin} min old (${data.source})`;
  
  // Moisture insights
  const spread = data.temp - data.dewpoint;
  let moisture = '';
  if (spread < 5) moisture = '‚ö†Ô∏è Near saturation - fog/mist likely';
  else if (spread < 10) moisture = 'Very humid - condensation on cold surfaces';
  else if (spread < 20) moisture = 'Comfortable moisture levels';
  else moisture = 'Dry air - static electricity likely';
  
  document.getElementById('moistureInsight').innerHTML = `
    <strong>Moisture Status:</strong> ${moisture}<br>
    <strong>VPD ${vaporPressureDeficit(data.temp, data.humidity)} kPa:</strong> 
    ${vaporPressureDeficit(data.temp, data.humidity) < 0.5 ? 'Air is saturated' : 
      vaporPressureDeficit(data.temp, data.humidity) > 2 ? 'Air is very thirsty' : 
      'Moderate moisture demand'}
  `;
  
  // Condensation risk
  const surfaces = [
    {name: 'Windows', temp: data.temp - 15},
    {name: 'Walls', temp: data.temp - 8},
    {name: 'Metal objects', temp: data.temp - 20}
  ];
  
  const risks = surfaces
    .filter(s => s.temp <= data.dewpoint)
    .map(s => s.name);
  
  document.getElementById('condensationRisk').innerHTML = risks.length > 0 ?
    `‚ö†Ô∏è <strong>Condensation likely on:</strong> ${risks.join(', ')}` :
    `‚úì <strong>No condensation risk</strong> - all surfaces above dew point`;
}

// Find weather twins
async function findTwins() {
  const myWeather = await weather.get(userLocation.lat, userLocation.lon);
  
  // Sample grid across US
  const twins = [];
  for(let lat = 25; lat <= 48; lat += 3) {
    for(let lon = -124; lon <= -67; lon += 4) {
      const w = await weather.get(lat, lon);
      
      // Calculate similarity
      const tempDiff = Math.abs(w.temp - myWeather.temp);
      const dewDiff = Math.abs(w.dewpoint - myWeather.dewpoint);
      const pressDiff = Math.abs(w.pressure - myWeather.pressure) / 10;
      
      const similarity = tempDiff + dewDiff + pressDiff;
      
      if (similarity < 5) {
        twins.push({lat, lon, weather: w, similarity});
      }
    }
  }
  
  // Sort by similarity
  twins.sort((a, b) => a.similarity - b.similarity);
  
  // Display
  const list = document.getElementById('twinsList');
  list.innerHTML = twins.slice(0, 5).map(t => `
    <div class="twin-card">
      <div>
        <strong>${t.lat.toFixed(1)}¬∞, ${t.lon.toFixed(1)}¬∞</strong><br>
        ${t.weather.temp}¬∞F / ${t.weather.dewpoint}¬∞ dew / ${t.weather.pressure} mb
      </div>
      <div>Match: ${Math.round(100 - t.similarity * 10)}%</div>
    </div>
  `).join('');
  
  // Add to map
  if (maps.twins) {
    twins.forEach(t => {
      L.circleMarker([t.lat, t.lon], {
        radius: 8,
        color: '#10b981',
        fillOpacity: 0.8
      }).bindPopup(`Weather twin! ${t.weather.temp}¬∞F`).addTo(maps.twins);
    });
  }
}

// Track pressure systems
async function trackPressure() {
  const systems = [];
  
  // Sample pressure across US
  for(let lat = 25; lat <= 48; lat += 2) {
    for(let lon = -124; lon <= -67; lon += 2) {
      const w = await weather.get(lat, lon);
      systems.push({lat, lon, pressure: w.pressure});
    }
  }
  
  // Find extremes
  systems.sort((a, b) => b.pressure - a.pressure);
  const highs = systems.slice(0, 5);
  const lows = systems.slice(-5);
  
  // Display
  const list = document.getElementById('pressureSystems');
  list.innerHTML = `
    <h3>High Pressure Centers (Clear/Stable)</h3>
    ${highs.map(h => `
      <span class="pressure-indicator high-pressure">${h.pressure} mb at ${h.lat.toFixed(1)}¬∞, ${h.lon.toFixed(1)}¬∞</span>
    `).join(' ')}
    
    <h3 style="margin-top: 1rem;">Low Pressure Centers (Storms/Fronts)</h3>
    ${lows.map(l => `
      <span class="pressure-indicator low-pressure">${l.pressure} mb at ${l.lat.toFixed(1)}¬∞, ${l.lon.toFixed(1)}¬∞</span>
    `).join(' ')}
  `;
  
  // Add to map
  if (maps.pressure) {
    highs.forEach(h => {
      L.circleMarker([h.lat, h.lon], {
        radius: 20,
        color: '#dc2626',
        fillOpacity: 0.3
      }).bindPopup(`HIGH: ${h.pressure} mb`).addTo(maps.pressure);
    });
    
    lows.forEach(l => {
      L.circleMarker([l.lat, l.lon], {
        radius: 20,
        color: '#3b82f6',
        fillOpacity: 0.3
      }).bindPopup(`LOW: ${l.pressure} mb`).addTo(maps.pressure);
    });
  }
}

// Weather roulette
async function roulette(lat, lon) {
  const clicked = await weather.get(lat, lon);
  
  // Find most different place
  let maxDiff = 0;
  let opposite = null;
  
  for(let testLat = 25; testLat <= 48; testLat += 5) {
    for(let testLon = -124; testLon <= -67; testLon += 5) {
      const w = await weather.get(testLat, testLon);
      const diff = Math.abs(w.temp - clicked.temp) + Math.abs(w.dewpoint - clicked.dewpoint);
      
      if (diff > maxDiff) {
        maxDiff = diff;
        opposite = {lat: testLat, lon: testLon, weather: w};
      }
    }
  }
  
  // Random wildcard
  const wildLat = 25 + Math.random() * 23;
  const wildLon = -124 + Math.random() * 57;
  const wildcard = await weather.get(wildLat, wildLon);
  
  // Display results
  document.getElementById('rouletteResults').innerHTML = `
    <h3>Your Click: ${lat.toFixed(1)}¬∞, ${lon.toFixed(1)}¬∞</h3>
    <div class="twin-card">
      ${clicked.temp}¬∞F / ${clicked.dewpoint}¬∞ dew / ${clicked.pressure} mb
    </div>
    
    <h3>Weather Opposite: ${opposite.lat.toFixed(1)}¬∞, ${opposite.lon.toFixed(1)}¬∞</h3>
    <div class="twin-card">
      ${opposite.weather.temp}¬∞F / ${opposite.weather.dewpoint}¬∞ dew / ${opposite.weather.pressure} mb
      <div>${maxDiff}¬∞ different!</div>
    </div>
    
    <h3>Wildcard: ${wildLat.toFixed(1)}¬∞, ${wildLon.toFixed(1)}¬∞</h3>
    <div class="twin-card">
      ${wildcard.temp}¬∞F / ${wildcard.dewpoint}¬∞ dew / ${wildcard.pressure} mb
    </div>
  `;
}

// Initialize maps
function initMaps() {
  // Local map
  maps.local = L.map('localMap').setView([userLocation.lat, userLocation.lon], 8);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(maps.local);
  
  const localMarker = L.marker([userLocation.lat, userLocation.lon]).addTo(maps.local);
  
  maps.local.on('click', async (e) => {
    userLocation = {lat: e.latlng.lat, lon: e.latlng.lng};
    localMarker.setLatLng(e.latlng);
    await updateLocal();
  });
  
  // Twins map
  maps.twins = L.map('twinsMap').setView([39, -98], 4);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(maps.twins);
  
  // Pressure map
  maps.pressure = L.map('pressureMap').setView([39, -98], 4);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(maps.pressure);
  
  // Roulette map
  maps.roulette = L.map('rouletteMap').setView([39, -98], 4);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(maps.roulette);
  
  maps.roulette.on('click', (e) => {
    roulette(e.latlng.lat, e.latlng.lng);
  });
}

// Tab switching
window.switchTab = function(tab) {
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  
  event.target.classList.add('active');
  document.getElementById(tab).classList.add('active');
  
  // Load data for tab
  if (tab === 'twins') findTwins();
  if (tab === 'pressure') trackPressure();
}

// Set location from input
window.setLocation = async function() {
  const input = document.getElementById('locationInput').value;
  // Here you'd geocode the input to lat/lon
  // For now, just update with current location
  await updateLocal();
}

// Initialize
window.addEventListener('DOMContentLoaded', () => {
  initMaps();
  updateLocal();
});
</script>

</body>
</html>
